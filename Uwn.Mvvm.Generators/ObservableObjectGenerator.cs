using System.Collections.Immutable;
using System.ComponentModel;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Uwn.Mvvm.Generators;

[Generator(LanguageNames.CSharp)]
public sealed class ObservableObjectGenerator
	: GeneratorBase, IIncrementalGenerator
{
	// {0} = Namespace
	// {1} = Class name
	// {2} = ObservableObject FQN
	private const string Source = @"// <auto-generated/>

namespace {0}
{{
    public partial class {1}
		: {2}
    {{
    }}
}}
";

	private static readonly string[] ForbiddenInterfaceNames = [nameof(INotifyPropertyChanging), nameof(INotifyPropertyChanged)];

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Find all class declarations
		var classDeclarations = context
			.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (node, _) => node is ClassDeclarationSyntax,
				transform: static (ctx, _) => (ClassDeclarationSyntax)ctx.Node)
			.Where(cds => cds is not null);

		// Get the semantic model and attribute symbol
		var compilationAndClasses = context
			.CompilationProvider
			.Combine(classDeclarations.Collect());

		// Generate the source
		context.RegisterSourceOutput(
			compilationAndClasses,
			static (spc, source) => Execute(source.Left, source.Right, spc)
			);
	}

	private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classDeclarations, SourceProductionContext context)
	{
		var attributeSymbol = compilation.GetTypeByMetadataName(StringValues.ObservableObjectAttributeFullyQualifiedName);
		if (attributeSymbol is null)
		{
			context.ReportDiagnostic(StringValues.ObservableObjectGeneratorIdPrefix, 1, DiagnosticSeverity.Error, StringValues.ObservableObjectGeneratorName, "Could not find type '{0}'.", StringValues.ObservableObjectAttributeFullyQualifiedName);
			return;
		}

		foreach (var classDeclaration in classDeclarations)
		{
			var location = classDeclaration.GetLocation();
			var model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);

			var classSymbol = model.GetDeclaredSymbol(classDeclaration);
			if (classSymbol is null)
			{
				context.ReportDiagnostic(StringValues.ObservableObjectGeneratorIdPrefix, 2, DiagnosticSeverity.Error, location, StringValues.ObservableObjectGeneratorName, "Could not find symbol for '{0}'.", classDeclaration.ToString());
				continue;
			}

			var hasAttribute = classSymbol.GetAttributes().Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, attributeSymbol));
			if (!hasAttribute)
			{
				// Removed the report, as it will otherwise show up on every single non-observable class.
				//context.ReportDiagnostic(StringValues.ObservableObjectGeneratorIdPrefix, 3, DiagnosticSeverity.Info, location, StringValues.ObservableObjectGeneratorName, "Class '{0}' does not have the '{1}' attribute.", classSymbol.Name, attributeSymbol.Name);
				continue;
			}

			var isPartial = classDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
			if (!isPartial)
			{
				context.ReportDiagnostic(StringValues.ObservableObjectGeneratorIdPrefix, 4, DiagnosticSeverity.Error, location, StringValues.ObservableObjectGeneratorName, "Class '{0}' must be declared as partial to use [{1}].", classSymbol.Name, StringValues.ObservableObjectAttributeName);
				continue;
			}

			var implementsForbiddenInterface = classSymbol.AllInterfaces.Any(i => ForbiddenInterfaceNames.Contains(i.Name));
			if (implementsForbiddenInterface)
				context.ReportDiagnostic(StringValues.ObservableObjectGeneratorIdPrefix, 5, DiagnosticSeverity.Warning, location, StringValues.ObservableObjectGeneratorName, "Class '{0}' already implements INotifyPropertyChanging or INotifyPropertyChanged, which might cause problems.", classSymbol.Name);

			// {0} = Namespace
			// {1} = Class name
			// {2} = ObservableObject FQN
			var source = string.Format(Source, classSymbol.ContainingNamespace, classSymbol.Name, StringValues.ObservableObjectFullyQualifiedName);
			var filename = BuildFilename(classSymbol.ContainingNamespace, classSymbol, null);
			context.AddSource(filename, SourceText.From(source, Encoding.UTF8));

			// Removed the report to decrease spam in the output
			//context.ReportDiagnostic(StringValues.ObservableObjectGeneratorIdPrefix, 6, DiagnosticSeverity.Info, location, StringValues.ObservableObjectGeneratorName, "Generated class '{0}'.", classSymbol.Name);
		}
	}
}